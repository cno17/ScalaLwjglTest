package yage.lwjgl.glfw

import org.lwjgl.glfw.GLFW.*
import org.lwjgl.glfw.GLFWErrorCallback
import org.lwjgl.opengl.GL.createCapabilities
import org.lwjgl.opengl.GL11C.*
import yage.lwjgl.StackUser
// import yage.lwjgl.gl.debug.DebugMessenger
import yage.lwjgl.glfw.input.Key
import yage.lwjgl.glfw.input.Keyboard
import yage.lwjgl.glfw.monitor.Monitor
import yage.lwjgl.glfw.window.Window
// import yage.lwjgl.nvg.Context

import java.io.File

// TODO init Keyboard and Mouse

trait AppOld extends StackUser:

  type EventProcessor = () => Unit

  var timer: Timer = null
  //var debugMessenger: DebugMessenger = null
  var eventProcessor: EventProcessor = null
  var frameCounter: FrameCounter = null
  // var nvgContext: Context = null

  def info() = WindowCreateInfo()
  // def create()
  def init() = {}
  def draw() = {}
  // def resized(sx: Int, sy: Int) = {} // TODO needs work
  def step(t: Int, dt: Int) = {}
  def step(t: Int, dt: Int) = {}
  def exit() = {}
  // def destroy()

  def main(args: Array[String]) = run()

  // trait FileSystemInfo

  def srcDir =
    val path = getClass.getPackage.getName.replace('.', '\\')
    // look at LearningOpenGl!
    File(getClass.getClassLoader.getResource(path).toURI)

  def resDir =
    File(getClass.getClassLoader.getResource(".").toURI)

  def srcFile(path: String) = File(srcDir, path)

  def resFile(path: String) = File(resDir, path)

  final def run() =
    create()
    init()
    // quick and dirty
    // Window.resizedListeners += resized
    // glfwSetWindowSize(window.handle, window.sizeX, window.sizeY)
    // 
    var t1 = System.nanoTime()
    var t2 = t1
    var dt = 0
    while !Window.shouldClose() do
      t2 = System.nanoTime()
      dt = ((t2 - t1) / 1000000).toInt
      t1 = t2
      draw()
      step(dt)
      frameCounter.step(dt)
      Window.swapBuffers()
      eventProcessor()
    exit()
    destroy()

  final def close() = glfwSetWindowShouldClose(Window.handle, true)

  protected def onError(code: Int, pDescription: Long) =
    val error = Error(code)
    val description = GLFWErrorCallback.getDescription(pDescription)
    println(s"$error, $description")

  protected def onCloseKeyPressed(key: Key) =
    if key == Key.Escape || key == Key.Q then close()

  // good idea?
  protected def onWindowResized(w: Int, h: Int) =
    glViewport(0, 0, w, h)

  protected def create() =
    glfwSetErrorCallback(onError)
    glfwInit()
    val i = info()
    i.hints.apply()
    val h = glfwCreateWindow(i.sizeX, i.sizeY, i.title, 0, 0)
    glfwMakeContextCurrent(h)
    createCapabilities()
    glfwSwapInterval(1)
    //
    // window = Window(h)
    Window.resizedListeners += onWindowResized
    Keyboard.keyPressedListeners += onCloseKeyPressed
    timer = Timer()
    // debugMessenger = DebugMessenger(i.hints.debugContext)
    eventProcessor = i.eventMode.eventProcessor
    frameCounter = FrameCounter()
    // nvgContext = Context(NanoVGGL3.nvgCreate(0))
    Monitor.primaryMonitor.centerWindow()

  protected def destroy() =
    Window.destroy()
    glfwTerminate
